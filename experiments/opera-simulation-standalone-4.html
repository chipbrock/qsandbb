<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OPERA Neutrino Timing Simulation</title>
  <script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    console.log('Starting simulation script...');
    const { useState, useEffect, useRef } = React;
    console.log('Hooks loaded');

const BlindedTimingExperiment = () => {
  console.log('BlindedTimingExperiment component called');
  // Experiment parameters
  const DISTANCE = 5000; // feet
  const CAR_SPEED = 10; // ft/s (scout car - our "speed of light")
  const TRUE_TRANSIT_CAR = DISTANCE / CAR_SPEED; // 500 seconds (car's measurement)
  
  const [isRunning, setIsRunning] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [bunches, setBunches] = useState([]);
  const [startRecords, setStartRecords] = useState([]);
  const [finishRecords, setFinishRecords] = useState([]);
  const [analysis, setAnalysis] = useState(null);
  const [scoutCarPosition, setScoutCarPosition] = useState(0);
  const [scoutCarComplete, setScoutCarComplete] = useState(false);
  const [scoutCarRunning, setScoutCarRunning] = useState(false);
  const [timingFixed, setTimingFixed] = useState(false);
  const [firstRunAnalysis, setFirstRunAnalysis] = useState(null);
  const [hasRunOnce, setHasRunOnce] = useState(false);
  const [apparentSpeed, setApparentSpeed] = useState(11); // ft/s - what faulty cable makes it look like
  const speed = 60; // Fixed at 60x
  const intervalRef = useRef(null);
  const scoutCarRef = useRef(null);
  
  // Derived constants (must come after apparentSpeed state)
  const RUNNER_SPEED_FACTOR = 1.0; // Runners travel at SAME speed as car (like neutrinos at c)
  const TRUE_SPEED = CAR_SPEED * RUNNER_SPEED_FACTOR; // actual runner speed = 10 ft/s
  const TRUE_TRANSIT = DISTANCE / TRUE_SPEED; // actual runner transit time = 500s
  const APPARENT_TRANSIT = DISTANCE / apparentSpeed; // What it looks like with faulty cable
  const SECRET_OFFSET = APPARENT_TRANSIT - TRUE_TRANSIT; // Negative = appears early
  const BUNCH_INTERVAL = 250; // seconds between bunches (increased to 250s to eliminate aliasing)
  const BUNCH_SPREAD = 6; // seconds (std dev of runners in a bunch) - increased for wider spread
  const RUNNERS_PER_BUNCH = 120;

  // Start scout car manually
  const startScoutCar = () => {
    setScoutCarRunning(true);
    // Just set it running, CSS will animate it
    setTimeout(() => {
      setScoutCarPosition(100);
      setTimeout(() => {
        setScoutCarComplete(true);
        setScoutCarRunning(false);
      }, 5000); // After 5 second animation
    }, 50);
  };

  // Generate a bunch of runners with significantly varied characteristics
  const generateBunch = (centerTime) => {
    const runners = [];
    // Dramatic variation: spread can be 0.4x to 1.8x the base
    const bunchSpread = BUNCH_SPREAD * (0.4 + Math.random() * 1.4);
    // Varying skewness but controlled to avoid extreme outliers
    const skew = (Math.random() - 0.5) * 1.2;
    // Random intensity variation (affects tail behavior)
    const tailWeight = 0.5 + Math.random() * 1.0;
    
    for (let i = 0; i < RUNNERS_PER_BUNCH; i++) {
      const u1 = Math.random();
      const u2 = Math.random();
      let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      
      // Apply skewness and tail weight
      if (Math.random() < tailWeight) {
        z = z + skew * Math.pow(Math.abs(z), 0.7);
      } else {
        z = z * 0.5; // Tighter core for some runners
      }
      
      const time = centerTime + z * bunchSpread;
      runners.push(time);
    }
    // Sort and shift so the earliest runner starts at centerTime (leading edge)
    const sorted = runners.sort((a, b) => a - b);
    const shift = centerTime - sorted[0];
    return sorted.map(t => t + shift);
  };

  // Start simulation
  const startSimulation = () => {
    if (analysis && !hasRunOnce) {
      setFirstRunAnalysis(analysis);
      setHasRunOnce(true);
    }
    setIsRunning(true);
    setIsPaused(false);
    setCurrentTime(0);
    setBunches([]);
    setStartRecords([]);
    setFinishRecords([]);
    setAnalysis(null);
    
    // Create first bunch at t=0 immediately
    const runners = generateBunch(0);
    setBunches([{
      id: 0,
      startTime: 0,
      runners: runners,
      positions: runners.map(() => 0),
      finished: runners.map(() => false),
      verticalPositions: runners.map(() => 10 + Math.random() * 100)
    }]);
    
    // Record start times for first bunch
    runners.forEach(runnerTime => {
      setStartRecords(prev => [...prev, Math.floor(runnerTime)]);
    });
  };

  // Stop/Resume toggle
  const togglePause = () => {
    setIsPaused(!isPaused);
  };

  // Fix timing (mimics OPERA fixing the cable)
  const fixTiming = () => {
    if (analysis && !firstRunAnalysis) {
      setFirstRunAnalysis(analysis);
    }
    setTimingFixed(true);
    setHasRunOnce(true);
    // Stop the simulation completely
    setIsRunning(false);
    setIsPaused(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
    // Clear all data so second run starts fresh
    setCurrentTime(0);
    setBunches([]);
    setFinishRecords([]);
    setStartRecords([]);
    setAnalysis(null);
  };

  // Reset simulation
  const reset = () => {
    setIsRunning(false);
    setIsPaused(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
    if (scoutCarRef.current) {
      clearInterval(scoutCarRef.current);
      scoutCarRef.current = null;
    }
    setCurrentTime(0);
    setBunches([]);
    setStartRecords([]);
    setFinishRecords([]);
    setAnalysis(null);
    setTimingFixed(false);
    setFirstRunAnalysis(null);
    setHasRunOnce(false);
    setScoutCarPosition(0);
    setScoutCarComplete(false);
    setScoutCarRunning(false);
    setApparentSpeed(11); // Reset to default
  };

  // Simulation loop
  useEffect(() => {
    if (!isRunning || isPaused) {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
      return;
    }

    intervalRef.current = setInterval(() => {
      setCurrentTime(t => {
        const newTime = t + 0.1 * speed;
        
        // Release new bunch every BUNCH_INTERVAL seconds
        if (Math.floor(newTime / BUNCH_INTERVAL) > Math.floor(t / BUNCH_INTERVAL)) {
          const bunchStartTime = Math.floor(newTime / BUNCH_INTERVAL) * BUNCH_INTERVAL;
          const runners = generateBunch(bunchStartTime);
          
          setBunches(prev => [...prev, {
            id: prev.length,
            startTime: bunchStartTime,
            runners: runners,
            positions: runners.map(() => 0),
            finished: runners.map(() => false),
            verticalPositions: runners.map(() => 10 + Math.random() * 100) // Assign once here
          }]);
          
          // Record start times (GPS ticks)
          runners.forEach(runnerTime => {
            setStartRecords(prev => [...prev, Math.floor(runnerTime)]);
          });
        }
        
        // Update bunch positions and record finishes
        setBunches(prev => prev.map(bunch => {
          const newPositions = [...bunch.positions];
          const newFinished = [...bunch.finished];
          
          bunch.runners.forEach((runnerStartTime, idx) => {
            const elapsed = newTime - runnerStartTime;
            const position = Math.min(elapsed * TRUE_SPEED, DISTANCE);
            newPositions[idx] = position;
            
            // Check if just crossed finish line
            if (position >= DISTANCE && !bunch.finished[idx]) {
              newFinished[idx] = true;
              const finishTime = runnerStartTime + TRUE_TRANSIT;
              // Apply systematic error (-5s) only if timing NOT fixed (mimics faulty cable adding delay)
              const systematicError = timingFixed ? 0 : SECRET_OFFSET;
              const recordedTime = Math.floor(finishTime + systematicError);
              setFinishRecords(prev => [...prev, recordedTime]);
            }
          });
          
          return {
            ...bunch,
            positions: newPositions,
            finished: newFinished
          };
        }).filter(bunch => 
          bunch.positions.some(pos => pos < DISTANCE) || 
          (newTime - bunch.startTime) < TRUE_TRANSIT + 10
        ));
        
        // Stop after enough time
        if (newTime > 2000) {
          setIsRunning(false);
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
          }
        }
        
        return newTime;
      });
    }, 100);

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [isRunning, isPaused, speed, timingFixed]);

  // Update analysis continuously as data arrives
  useEffect(() => {
    if (startRecords.length > 20 && finishRecords.length > 20) {
      analyzeData();
    }
  }, [startRecords.length, finishRecords.length]);

  // Analyze data
  const analyzeData = () => {
    // Create histograms
    const startHist = {};
    const finishHist = {};
    
    startRecords.forEach(tick => {
      startHist[tick] = (startHist[tick] || 0) + 1;
    });
    
    finishRecords.forEach(tick => {
      finishHist[tick] = (finishHist[tick] || 0) + 1;
    });
    
    // Calculate correlation curve across wide range (300-600s) for display
    const correlations = [];
    for (let offset = 300; offset < 600; offset += 0.5) {
      let correlation = 0;
      let count = 0;
      
      Object.keys(startHist).forEach(startTick => {
        const expectedFinish = parseFloat(startTick) + offset;
        const finishBin = Math.floor(expectedFinish);
        
        if (finishHist[finishBin]) {
          correlation += startHist[startTick] * finishHist[finishBin];
          count++;
        }
      });
      
      if (count > 0) {
        correlations.push({ offset, correlation: correlation / count });
      }
    }
    
    // Find best offset - search range adapts to apparent speed
    const maxCorr = Math.max(...correlations.map(c => c.correlation), 1);
    // Search within ¬±50s of expected apparent transit time
    const searchMin = Math.max(300, APPARENT_TRANSIT - 50);
    const searchMax = Math.min(600, APPARENT_TRANSIT + 50);
    const peakSearchRange = correlations.filter(c => c.offset >= searchMin && c.offset <= searchMax);
    const bestOffset = peakSearchRange.length > 0
      ? peakSearchRange.reduce((max, c) => c.correlation > max.correlation ? c : max, peakSearchRange[0]).offset
      : TRUE_TRANSIT;
    
    // Calculate statistical uncertainty from correlation peak width
    // Find FWHM (full width at half maximum) as estimate of uncertainty
    const halfMax = maxCorr / 2;
    const aboveHalfMax = correlations.filter(c => c.correlation >= halfMax);
    let uncertainty = 0;
    if (aboveHalfMax.length > 0) {
      const minOffset = Math.min(...aboveHalfMax.map(c => c.offset));
      const maxOffset = Math.max(...aboveHalfMax.map(c => c.offset));
      // FWHM / 2.355 gives approximate 1-sigma uncertainty for Gaussian
      uncertainty = (maxOffset - minOffset) / 2.355;
    }
    
    const measuredTransit = bestOffset;
    const apparentSpeed = DISTANCE / measuredTransit;
    const deltaT = TRUE_TRANSIT_CAR - measuredTransit;
    
    setAnalysis({
      measuredTransit,
      apparentSpeed,
      correlations,
      maxCorr,
      uncertainty,
      deltaT
    });
  };

  return (
    <div className="w-full max-w-6xl mx-auto p-6 bg-gradient-to-br from-slate-50 to-slate-100 rounded-lg shadow-lg">
      <h1 className="text-3xl font-bold text-slate-800 mb-2">
        Blinded GPS Timing Experiment
      </h1>
      <p className="text-slate-600 mb-6">Mimicking OPERA's methodology with runners, GPS, and statistical correlation</p>
      
      {/* Controls */}
      <div className="flex gap-4 mb-6 items-center flex-wrap">
        {!scoutCarComplete && !scoutCarRunning && (
          <button
            onClick={startScoutCar}
            className="flex items-center gap-2 px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
          >
            <span style={{ display: 'inline-block', transform: 'scaleX(-1)' }}>üöó</span> Start Scout Car
          </button>
        )}
        
        <button
          onClick={startSimulation}
          disabled={(isRunning && !isPaused) || !scoutCarComplete}
          className="flex items-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
        >
          ‚ñ∂Ô∏è
          {!scoutCarComplete ? 'Waiting for scout car...' : (hasRunOnce && !isRunning ? 'Run Again' : 'Start Simulation')}
        </button>
        
        {isRunning && (
          <button
            onClick={togglePause}
            className="flex items-center gap-2 px-6 py-3 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 transition-colors"
          >
            {isPaused ? <>‚ñ∂Ô∏è</> : <span className="w-5 h-5 flex items-center justify-center">‚è∏</span>}
            {isPaused ? 'Resume' : 'Pause'}
          </button>
        )}
        
        {!isRunning && analysis && !timingFixed && (
          <button
            onClick={fixTiming}
            className="flex items-center gap-2 px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
          >
            üîß Fix Timing Problem
          </button>
        )}
        
        <button
          onClick={reset}
          className="flex items-center gap-2 px-6 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors"
        >
          üîÑ
          Reset
        </button>
      </div>

      {/* Experiment Parameters */}
      <div className="bg-white rounded-lg p-3 mb-4 shadow">
        <h2 className="text-md font-bold text-slate-800 mb-2">Experiment Setup</h2>
        <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-xs">
          <div className="flex justify-between">
            <span className="text-slate-500">Distance:</span>
            <span className="font-bold text-slate-800">{DISTANCE} feet</span>
          </div>
          {scoutCarComplete && (
            <div className="flex justify-between">
              <span className="text-red-600 font-bold">TOF<sub>car</sub>:</span>
              <span className="font-bold text-red-600">{TRUE_TRANSIT_CAR}s</span>
            </div>
          )}
          <div className="flex justify-between">
            <span className="text-slate-500">Runner Speed:</span>
            <span className="font-bold text-slate-800">{TRUE_SPEED.toFixed(2)} ft/s</span>
          </div>
          <div className="flex justify-between">
            <span className="text-slate-500">GPS Tick Rate:</span>
            <span className="font-bold text-slate-800">1 Hz</span>
          </div>
          <div className="flex justify-between">
            <span className="text-slate-500">Bunch Width:</span>
            <span className="font-bold text-slate-800">{(BUNCH_SPREAD * 2.5).toFixed(0)}s (runners in each group)</span>
          </div>
          <div className="flex justify-between">
            <span className="text-slate-500">Bunch Spacing:</span>
            <span className="font-bold text-slate-800">{BUNCH_INTERVAL}s (time between groups)</span>
          </div>
          <div className="col-span-2 mt-2">
            <label className="text-slate-500 text-xs block mb-1">
              Apparent Speed (faulty cable): {apparentSpeed.toFixed(1)} ft/s
            </label>
            <input
              type="range"
              min="10"
              max="15"
              step="0.1"
              value={apparentSpeed}
              onChange={(e) => setApparentSpeed(parseFloat(e.target.value))}
              disabled={isRunning || hasRunOnce}
              className="w-full"
            />
            <div className="flex justify-between text-xs text-slate-400 mt-1">
              <span>10 ft/s (no error)</span>
              <span>15 ft/s (max error)</span>
            </div>
          </div>
          {!timingFixed && hasRunOnce && (
            <div className="col-span-2 mt-1 p-2 bg-red-50 border border-red-200 rounded text-xs">
              <span className="text-red-700 font-medium">‚ö†Ô∏è FAULTY CABLE:</span>
              <span className="text-red-800"> Systematic error of <strong>{SECRET_OFFSET.toFixed(2)}s</strong> in timing</span>
            </div>
          )}
          {timingFixed && (
            <div className="col-span-2 mt-1 p-2 bg-green-50 border border-green-200 rounded text-xs">
              <span className="text-green-700 font-medium">‚úÖ CABLE FIXED:</span>
              <span className="text-green-800"> No systematic error</span>
            </div>
          )}
        </div>
      </div>

      {/* Scout Car Animation */}
      {!scoutCarComplete && (
        <div className="bg-white rounded-lg p-4 mb-6 shadow">
          <h2 className="text-lg font-bold text-slate-800 mb-3">
            <span style={{ display: 'inline-block', transform: 'scaleX(-1)' }}>üöó</span> Scout Car Measuring Distance
          </h2>
          <p className="text-sm text-slate-600 mb-4">
            The scout car travels at {CAR_SPEED} ft/s to measure the distance. This establishes our reference time: TOF<sub>car</sub> = {TRUE_TRANSIT_CAR}s
          </p>
          <div className="relative h-24 bg-slate-100 rounded border-2 border-slate-300">
            {/* Source (left side green bar) */}
            <div className="absolute left-0 top-0 bottom-0 w-1 bg-green-500"></div>
            <div className="absolute left-2 top-1/2 -translate-y-1/2 text-xs font-bold text-green-700" style={{ writingMode: 'vertical-lr' }}>
              SOURCE
            </div>
            
            {/* Detector (right side red bar) */}
            <div className="absolute right-0 top-0 bottom-0 w-2 bg-red-500"></div>
            <div className="absolute right-3 top-1/2 -translate-y-1/2 text-xs font-bold text-red-700" style={{ writingMode: 'vertical-lr' }}>
              DETECTOR
            </div>
            
            {/* Scout car - emoji pointing right */}
            <div
              className="absolute h-6 text-2xl"
              style={{
                left: `${scoutCarPosition}%`,
                top: '50%',
                transform: 'translateY(-50%) scaleX(-1)',
                transition: scoutCarRunning ? 'left 5s linear' : 'none'
              }}
            >
              üöó
            </div>
          </div>
          <div className="mt-2 text-center text-slate-600 text-sm">
            Progress: {scoutCarPosition.toFixed(1)}%
          </div>
        </div>
      )}

      {/* Track Visualization */}
      <div className="bg-white rounded-lg p-4 mb-6 shadow">
        <h2 className="text-lg font-bold text-slate-800 mb-3">Track with Runners (5000 feet)</h2>
        <div className="relative">
          {/* Track */}
          <div className="relative h-32 bg-slate-100 rounded border-2 border-slate-300 mb-8">
            {/* Start and Finish lines */}
            <div className="absolute left-0 top-0 bottom-0 w-1 bg-green-500">
              <div className="absolute left-2 top-1/2 -translate-y-1/2 text-xs font-bold text-green-700 whitespace-nowrap" style={{ writingMode: 'vertical-lr' }}>
                SOURCE
              </div>
            </div>
            <div className="absolute right-0 top-0 bottom-0 w-2 bg-red-500">
              <div className="absolute right-3 top-1/2 -translate-y-1/2 text-xs font-bold text-red-700 whitespace-nowrap" style={{ writingMode: 'vertical-lr' }}>
                DETECTOR
              </div>
            </div>
            
            {/* Distance markers */}
            <div className="absolute left-0 -bottom-6 text-xs text-slate-500">Start (0 ft)</div>
            <div className="absolute left-1/4 -bottom-6 text-xs text-slate-500">1250 ft</div>
            <div className="absolute left-1/2 -bottom-6 text-xs text-slate-500">2500 ft</div>
            <div className="absolute left-3/4 -bottom-6 text-xs text-slate-500">3750 ft</div>
            <div className="absolute right-0 -bottom-6 text-xs text-slate-500">Finish (5000 ft)</div>
            
            {/* Runners - blue before finish, orange after */}
            {bunches.map(bunch => {
              // Calculate the spatial extent of this bunch
              const minTime = Math.min(...bunch.runners);
              const maxTime = Math.max(...bunch.runners);
              const bunchWidth = (maxTime - minTime) * TRUE_SPEED; // in feet
              
              return bunch.positions.map((pos, idx) => {
                if (pos >= DISTANCE) {
                  // Finished - show at finish line
                  return (
                    <div
                      key={`${bunch.id}-${idx}`}
                      className="absolute w-2 h-2 rounded-full bg-orange-500 transition-all duration-100"
                      style={{
                        left: '100%',
                        top: `${bunch.verticalPositions[idx]}px`
                      }}
                    ></div>
                  );
                }
                
                // Still running - distribute within bunch
                const runnerTime = bunch.runners[idx];
                const relativeTime = runnerTime - minTime;
                const relativePosition = (relativeTime / (maxTime - minTime)) * bunchWidth;
                // Leaders (early starters) are BEHIND, trailers (late starters) are AHEAD in space
                // because they haven't traveled as far yet
                const actualPosition = pos - relativePosition; 
                const leftPercent = Math.max(0, Math.min(100, (actualPosition / DISTANCE) * 100));
                
                return (
                  <div
                    key={`${bunch.id}-${idx}`}
                    className="absolute w-2 h-2 rounded-full bg-blue-600 transition-all duration-100"
                    style={{
                      left: `${leftPercent}%`,
                      top: `${bunch.verticalPositions[idx]}px`
                    }}
                  ></div>
                );
              });
            })}
          </div>
        </div>
        
        <div className="mt-8 text-center text-slate-600">
          Time: <span className="font-bold">{currentTime.toFixed(1)}s</span> | 
          Bunches released: <span className="font-bold">{Math.floor(currentTime / BUNCH_INTERVAL)}</span> | 
          Runners at detector: <span className="font-bold text-orange-600">{finishRecords.length}</span>
        </div>
      </div>

      {/* Pattern Correlation Analysis - FIRST */}
      {analysis && analysis.correlations && (
        <div className="bg-white rounded-lg p-4 mb-4 shadow">
          <h2 className="text-lg font-bold text-slate-800 mb-3">
            üìä Time Pattern Correlation Analysis
            {timingFixed && <span className="text-green-600 ml-2">‚úÖ FIXED</span>}
            {!timingFixed && hasRunOnce && <span className="text-red-600 ml-2">‚ö†Ô∏è FAULTY</span>}
          </h2>
          <p className="text-sm text-slate-600 mb-4">
            Finding the time offset that gives the best match between departure and arrival patterns
          </p>
          
          <div>
            {/* Correlation curve */}
            <div className="relative h-48 bg-slate-50 rounded border border-slate-200 mb-4">
              {/* Best fit marker with uncertainty */}
              <div className="absolute" style={{ left: `${((analysis.measuredTransit - 300) / 300) * 100}%` }}>
                <div className="w-1 h-full bg-blue-500 opacity-70"></div>
                <div className="absolute top-0 left-2 text-xs font-bold whitespace-nowrap text-blue-600 bg-white px-1 rounded shadow">
                  Best fit: {analysis.measuredTransit.toFixed(2)}
                  {analysis.uncertainty > 0 && <span> ¬± {analysis.uncertainty.toFixed(2)}</span>}s
                </div>
              </div>
              
              {/* Correlation curve */}
              <svg className="absolute inset-0 w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
                {/* Uncertainty band (1-sigma region around peak) */}
                {analysis.uncertainty > 0 && (
                  <rect
                    x={((analysis.measuredTransit - analysis.uncertainty - 300) / 300) * 100}
                    y={0}
                    width={(2 * analysis.uncertainty / 300) * 100}
                    height={100}
                    fill="rgba(59, 130, 246, 0.1)"
                  />
                )}
                {/* Correlation curve line */}
                <polyline
                  points={analysis.correlations.map(c => 
                    `${((c.offset - 300) / 300) * 100},${100 - (c.correlation / analysis.maxCorr) * 90}`
                  ).join(' ')}
                  fill="none"
                  stroke="rgb(59, 130, 246)"
                  strokeWidth="0.5"
                />
              </svg>
              
              {/* VERTICAL GRAY LINE AT 500s - USING SVG SO IT DEFINITELY RENDERS */}
              <svg className="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 100 100" preserveAspectRatio="none" style={{ zIndex: 100 }}>
                <line
                  x1={((500 - 300) / 300) * 100}
                  y1={0}
                  x2={((500 - 300) / 300) * 100}
                  y2={100}
                  stroke="red"
                  strokeWidth="0.3"
                  strokeDasharray="2,2"
                />
              </svg>
              <div className="absolute pointer-events-none" style={{ left: `${((500 - 300) / 300) * 100}%`, top: '-1.5rem', zIndex: 101 }}>
                <div className="text-xs text-red-600 font-bold whitespace-nowrap bg-white px-1 -translate-x-1/2">
                  500s
                </div>
              </div>
            </div>
            
            {/* Tick marks */}
            <div className="relative h-10">
              {[300, 350, 400, 450, 500, 550, 600].map(tick => {
                const x = ((tick - 300) / 300) * 100;
                return (
                  <div key={tick} className="absolute" style={{ left: `${x}%` }}>
                    <div className="w-px h-4 bg-slate-400"></div>
                    <div className="text-xs text-slate-600 transform -translate-x-1/2 mt-1">
                      {tick}s
                    </div>
                  </div>
                );
              })}
            </div>
            
            <div className="mt-4 p-3 bg-slate-50 rounded text-xs">
              <strong>Method:</strong> Cross-correlation Œ£ S[t] √ó A[t + Œît]. Light blue band shows ¬±1œÉ uncertainty (from peak width).
              Green line shows expected arrival for 10 ft/s speed.
            </div>
          </div>
        </div>
      )}

      {/* Delta T Display - SECOND */}
      {analysis && (
        <div className="bg-white rounded-lg p-4 mb-4 shadow border-2 border-purple-300">
          <h2 className="text-lg font-bold text-slate-800 mb-3">
            üìà Œ¥t Measurement
            {timingFixed && <span className="text-green-600 ml-2">‚úÖ FIXED</span>}
            {!timingFixed && hasRunOnce && <span className="text-red-600 ml-2">‚ö†Ô∏è FAULTY</span>}
          </h2>
          <div className="p-4 bg-purple-50 rounded-lg mb-3">
            <div className="text-sm text-purple-600 mb-2">Current measurement:</div>
            <div className="text-2xl font-mono font-bold text-purple-900">
              Œ¥t = {TRUE_TRANSIT_CAR} - {analysis.measuredTransit.toFixed(2)} = {analysis.deltaT.toFixed(2)} s
              {analysis.uncertainty > 0 && <span className="text-lg"> ¬± {analysis.uncertainty.toFixed(2)} s</span>}
            </div>
            <div className="text-xs text-purple-700 mt-2">
              Œ¥t = TOF<sub>car</sub> - TOF<sub>runners</sub> where TOF<sub>runners</sub> is measured from correlation peak
            </div>
          </div>
          <div className="grid grid-cols-3 gap-3 text-xs">
            <div className="p-2 bg-blue-50 rounded">
              <div className="text-blue-600">TOF<sub>car</sub> (reference)</div>
              <div className="font-bold text-blue-900">{TRUE_TRANSIT_CAR} s</div>
            </div>
            <div className="p-2 bg-green-50 rounded">
              <div className="text-green-600">TOF<sub>runners</sub> (measured)</div>
              <div className="font-bold text-green-900">{analysis.measuredTransit.toFixed(2)} s</div>
            </div>
            <div className="p-2 bg-purple-50 rounded">
              <div className="text-purple-600">Expected Œ¥t</div>
              <div className="font-bold text-purple-900">{(TRUE_TRANSIT_CAR - TRUE_TRANSIT).toFixed(2)} s</div>
            </div>
          </div>
        </div>
      )}

      {/* Live Delta T Accumulation - REMOVED (merged above) */}

      {/* Pattern Correlation Analysis - REMOVED (moved to top) */}

      {/* Comparison: Before and After Fix */}
      {firstRunAnalysis && timingFixed && analysis && (
        <div className="bg-white rounded-lg p-4 mb-4 shadow border-2 border-green-400">
          <h2 className="text-xl font-bold text-slate-800 mb-3">üîß Before and After Timing Fix</h2>
          
          {/* Side-by-side correlation plots */}
          <div className="mb-4">
            {/* Overlaid Before/After Correlation Plot */}
            <div className="p-3 bg-slate-50 rounded-lg border-2 border-slate-300">
              <h3 className="font-bold text-slate-800 mb-2 text-sm">Before (red) vs After (green) Correlation</h3>
              <div className="relative h-32 bg-white rounded border border-slate-200">
                {/* Gray vertical line at 500s */}
                <div className="absolute pointer-events-none z-50" style={{ left: `${((500 - 300) / 300) * 100}%` }}>
                  <div className="w-0.5 h-full bg-black opacity-50"></div>
                </div>
                
                {/* SVG for both curves */}
                <svg className="absolute inset-0 w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
                  {/* Before fix curve (red) */}
                  <polyline
                    points={firstRunAnalysis.correlations.map(c => 
                      `${((c.offset - 300) / 300) * 100},${100 - (c.correlation / firstRunAnalysis.maxCorr) * 90}`
                    ).join(' ')}
                    fill="none"
                    stroke="rgb(239, 68, 68)"
                    strokeWidth="0.5"
                    opacity="0.9"
                  />
                  {/* After fix curve (green) */}
                  <polyline
                    points={analysis.correlations.map(c => 
                      `${((c.offset - 300) / 300) * 100},${100 - (c.correlation / analysis.maxCorr) * 90}`
                    ).join(' ')}
                    fill="none"
                    stroke="rgb(34, 197, 94)"
                    strokeWidth="0.5"
                    opacity="0.9"
                  />
                  
                  {/* VERTICAL RED DASHED LINE AT 500s */}
                  <line
                    x1={((500 - 300) / 300) * 100}
                    y1={0}
                    x2={((500 - 300) / 300) * 100}
                    y2={100}
                    stroke="red"
                    strokeWidth="0.3"
                    strokeDasharray="2,2"
                  />
                </svg>
                
                {/* Peak markers */}
                <div className="absolute" style={{ left: `${((firstRunAnalysis.measuredTransit - 300) / 300) * 100}%` }}>
                  <div className="w-1 h-full bg-red-500 opacity-50"></div>
                </div>
                <div className="absolute" style={{ left: `${((analysis.measuredTransit - 300) / 300) * 100}%` }}>
                  <div className="w-1 h-full bg-green-600 opacity-50"></div>
                </div>
              </div>
              {/* Time axis */}
              <div className="relative h-6 mt-1">
                {[300, 400, 500, 600].map(tick => {
                  const x = ((tick - 300) / 300) * 100;
                  return (
                    <div key={tick} className="absolute" style={{ left: `${x}%` }}>
                      <div className="text-xs text-slate-600 transform -translate-x-1/2">
                        {tick}s
                      </div>
                    </div>
                  );
                })}
              </div>
              <div className="grid grid-cols-2 gap-2 text-xs mt-2">
                <div className="text-red-700 text-xs">
                  ‚ùå Before: Peak at {firstRunAnalysis.measuredTransit.toFixed(2)}s
                </div>
                <div className="text-green-700 text-xs">
                  ‚úÖ After: Peak at {analysis.measuredTransit.toFixed(2)}s
                </div>
              </div>
            </div>
          </div>

          <div className="grid md:grid-cols-2 gap-4">
            {/* Before Fix */}
            <div className="p-4 bg-red-50 rounded-lg border-2 border-red-300">
              <h3 className="font-bold text-red-800 mb-3">‚ùå Before Fix (Faulty Cable)</h3>
              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className="text-red-700">TOF<sub>runners</sub> measured:</span>
                  <span className="font-bold">{firstRunAnalysis.measuredTransit.toFixed(2)} ¬± {firstRunAnalysis.uncertainty.toFixed(2)}s</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-red-700">Œ¥t calculated:</span>
                  <span className="font-bold">{firstRunAnalysis.deltaT.toFixed(2)} ¬± {firstRunAnalysis.uncertainty.toFixed(2)}s</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-red-700">Expected Œ¥t:</span>
                  <span className="font-bold">{(TRUE_TRANSIT_CAR - TRUE_TRANSIT).toFixed(2)}s</span>
                </div>
                <div className="flex justify-between border-t border-red-200 pt-2 mt-2">
                  <span className="text-red-700">Systematic error:</span>
                  <span className="font-bold text-red-900">{(firstRunAnalysis.deltaT - (TRUE_TRANSIT_CAR - TRUE_TRANSIT)).toFixed(2)}s</span>
                </div>
              </div>
            </div>

            {/* After Fix */}
            <div className="p-4 bg-green-50 rounded-lg border-2 border-green-300">
              <h3 className="font-bold text-green-800 mb-3">‚úÖ After Fix (Cable Repaired)</h3>
              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className="text-green-700">TOF<sub>runners</sub> measured:</span>
                  <span className="font-bold">{analysis.measuredTransit.toFixed(2)} ¬± {analysis.uncertainty.toFixed(2)}s</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-green-700">Œ¥t calculated:</span>
                  <span className="font-bold">{analysis.deltaT.toFixed(2)} ¬± {analysis.uncertainty.toFixed(2)}s</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-green-700">Expected Œ¥t:</span>
                  <span className="font-bold">{(TRUE_TRANSIT_CAR - TRUE_TRANSIT).toFixed(2)}s</span>
                </div>
                <div className="flex justify-between border-t border-green-200 pt-2 mt-2">
                  <span className="text-green-700">Systematic error:</span>
                  <span className="font-bold text-green-900">{(analysis.deltaT - (TRUE_TRANSIT_CAR - TRUE_TRANSIT)).toFixed(2)}s</span>
                </div>
              </div>
            </div>
          </div>

          <div className="mt-4 p-3 bg-blue-50 rounded text-sm">
            <strong>OPERA Story:</strong> In September 2011, OPERA reported neutrinos arriving ~60 ns early (faster than light!). 
            After months of scrutiny, they found a faulty fiber optic cable connection and a clock oscillator issue. 
            After repairs in 2012, measurements were consistent with light speed (Œ¥t ‚âà 0).
          </div>
        </div>
      )}
    </div>
  );
};


    console.log('Component defined, about to render...');
    console.log('BlindedTimingExperiment exists:', typeof BlindedTimingExperiment);
    ReactDOM.render(React.createElement(BlindedTimingExperiment), document.getElementById('root'));
    console.log('Render completed');
  </script>
</body>
</html>
